---
title: '最上位関数を呼び出し可能としてマップに渡します'
---

## 概要
明確にしておきますが、私は eval が悪であることを認識しています。これは製品コード用ではありません。そうは言っても、ゴルフの目的で、以下を短縮できるかどうか考えようとしています。

```
$*.map{eval _1}

```
さらに、次の場合とほぼ同じ方法で:

```
$*.map{|x|x.to_i}
# and
$*.map{_1.to_i}

```
次のように短縮できます:

```
$*.map(&:to_i)

```
Python のファーストクラス関数を使用すると、これが簡単になります。次のようなリストコンプ:

```
[eval(x)for x in sys.argv[1:]]

```
次のように短縮できます:

```
[*map(eval,sys.argv[1:])]

```
eval はファーストクラス関数であり、括弧がないと呼び出されないためです。しかし、渡される前に実行しようとする eval を抑制するために考えられることはすべて試しました。 .map(&eval)、.map(:eval)、およびそれらのバリエーションは機能しません (引数なしで eval を呼び出すか、eval 関数として機能しないものを渡すため)。

これはゴルフできない可能性がありますが、渡すことができる eval への直接参照を取得する（内部で呼び出す新しいカスタム Proc やラムダなどを作成するのではなく）方法があるかどうか興味があります。議論として？

(念のため言っておきますが、これは実際のコードゴルフの課題ではないので、StackOverflow のトピックに留まっていると思います。たまたまゴルフのためにこれをやりたいと思っているのですが、トップレベルの関数をファーストクラスのオブジェクトに変換できるということです。ゴルフ以外でも場合によってはそれらを渡すと便利です）

## 解決策
eval は、Ruby の他のほとんどの「関数のふりをするメソッド」と同様、カーネルのメソッドであるため、Object#method を使用して参照を取得できます。次に、 & to を使用してその Method を Proc に変換します。

```
$*.map(&method(:eval))

```
したがって、method(:eval) は eval への「直接参照」になります。ただし、#map が満足するものを取得するには、#to_proc を呼び出す必要があります。

メソッドの長さのせいでゴルフにはあまり向いていないかもしれないが、他に何も思いつかない。

